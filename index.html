<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <link rel="shortcut icon" href="favicon.ico">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spooky Eyes – Reduced Vergence</title>
  <style>
    html, body { height: 100%; margin: 0; background:#000; }
    .wrap { height: 100%; display: grid; place-items: center; }
    canvas { display: block; max-width: 100vw; max-height: 100vh; }
    .hud { position: fixed; left: 12px; top: 12px; color: #9ff; font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; opacity: 0.9; }
    .hud .badge { display:inline-block; padding:2px 6px; border-radius:6px; background:#124; margin-left:6px; }
    video { display:none; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="stage"></canvas>
  </div>
  <div class="hud">
    <div><strong>Spooky Eyes</strong> <span id="camStatus" class="badge">camera: off</span></div>
    <button id="soundToggle" class="badge" style="cursor:pointer">sound: off</button>
    <div>Camera-only • Parallelized gaze (reduced vergence) • Micro‑saccades • Luminance-reactive pupils</div>
  </div>
  <video id="camera" playsinline muted></video>

  <script type="module">

  // =============================================================
  // CONFIG – tweak freely
  // =============================================================
  const CONFIG = {
    // Artwork
    // Artwork
    bgUrl: "background.png",
    fgUrl: "foreground.png",

    // Canvas logical size when bg not provided
    width: 1920,
    height: 1080,

    // Eye positions (center and master radius per pair)
    eyes: [
      { x: 260,  y: 595,  r: 220 },
      { x: 330,  y: 823,  r: 230 },
      { x: 506,  y: 402,  r: 240 },
      { x: 645,  y: 693,  r: 310 },
      { x: 810,  y: 300,  r: 260 },
      { x: 953,  y: 817,  r: 220 },
      { x: 1125, y: 488,  r: 270 },
      { x: 1331, y: 747,  r: 240 },
    ],


    // Eye geometry/style (ratios)
    scleraR: 0.43,
    irisR:   0.20,
    limbalW: 0.028,
    pupilMin: 0.040,
    pupilMax: 0.18,

    // Gaze behaviour
    gaze: {
      mirrorCamera: true,   // mirror horizontally like a selfie
      range: 0.36,          // max pupil offset as fraction of r
      smooth: 0.18,         // low-pass smoothing 0..1
      vergence: 0.30        // 0 = parallel (far fixation), 1 = converge to point (near)
    },

    // Blinks
    blinkMinDelay: 12.0,
    blinkMaxDelay: 24.0,
    blinkDur: 0.15,

    // Micro‑saccades & tremor
    micro: {
      saccadeEveryMin: 0.6,
      saccadeEveryMax: 1.8,
      saccadeAmpMin: 0.005,
      saccadeAmpMax: 0.02,
      saccadeDurMin: 0.025,
      saccadeDurMax: 0.060,
      tremorHz1: 7.0,
      tremorHz2: 12.0,
      tremorAmp: 0.006
    },

    // Pupil response to camera luminance
    luminance: {
      sampleSize: 64,   // downsample N x N
      smooth: 0.15,     // EMA smooth 0..1
      targetLag: 0.25,  // seconds (per-eye varied)
      gamma: 0.8,       // brightness curve
      jitter: 0.03      // per-eye randomness on target fraction
    }
  };

  // Sprite config
  const SPRITE = {
    spiderUrl: 'spider32.png',
    cols: 8, rows: 4, total: 32,
    fps: 60, count: 1,
    rotationOffset: -Math.PI / 2   // rotate 90° clockwise; swap sign if you need CCW
  };


// Spider sprite sheet
const spiderSheet = new Image();
let spiderReady = false;
spiderSheet.onload = () => spiderReady = true;
spiderSheet.src = SPRITE.spiderUrl; // 'spider32.png' in the same folder

  // =============================================================
  // Helpers
  // =============================================================
  const lerp = (a,b,t)=> a + (b-a)*t;
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const now = () => performance.now() / 1000;
  const rr = (lo,hi)=> lo + Math.random()*(hi-lo);

class SpriteRunner {
  constructor(img, cols, rows, total, fps){
    this.img = img; this.cols = cols; this.rows = rows;
    this.total = total; this.fps = fps;
    this.accum = 0; this.f = 0;

    // offscreen buffer for tinting without boxing the background
    this.buf = document.createElement('canvas');
    this.bctx = this.buf.getContext('2d');
  }
  step(dt){
    this.accum += dt * this.fps;
    const adv = this.accum|0;
    if (adv > 0){ this.f = (this.f + adv) % this.total; this.accum -= adv; }
  }
  draw(ctx, x, y, scale=1, angleRad=0, tintSilhouette=true){
    if (!this.img.complete || !this.img.naturalWidth) return;

    const fw = this.img.naturalWidth  / this.cols;
    const fh = this.img.naturalHeight / this.rows;
    if (this.buf.width !== fw || this.buf.height !== fh){
      this.buf.width = fw; this.buf.height = fh;
    }

    const c = this.f % this.cols, r = (this.f / this.cols) | 0;
    const sx = c * fw, sy = r * fh;

    // --- draw current frame into the offscreen ---
    this.bctx.clearRect(0, 0, fw, fh);
    this.bctx.drawImage(this.img, sx, sy, fw, fh, 0, 0, fw, fh);

    // optional near-silhouette tint, masked by sprite alpha only
    if (tintSilhouette){
      this.bctx.globalCompositeOperation = 'source-atop';
      this.bctx.fillStyle = 'rgba(0,0,0,0.55)';
      this.bctx.fillRect(0, 0, fw, fh);
      this.bctx.globalCompositeOperation = 'source-over';
    }

    // --- paint to main canvas, rotated to travel direction ---
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angleRad + (SPRITE.rotationOffset || 0));
    ctx.scale(scale, scale);
    // anchor at bottom-center
    ctx.drawImage(this.buf, -fw/2, -fh, fw, fh);
    ctx.restore();
  }
}

// =============================================================
// Sound Manager
// =============================================================
class SoundMgr {
  constructor() {
    // asset paths (put your actual filenames here)
    this.paths = {
      swamp:   'swamp.mp3',
      crows:   'crows.mp3',
      owl:     'owl.mp3',
      raven:   'raven.mp3',
      monster: 'monster.mp3',
      footsteps: 'footsteps.mp3',
    };

    // random interval ranges in seconds
    this.ranges = {
      crows:   [20, 40],
      owl:     [10, 30],
      raven:   [30, 60],
      monster: [60, 90],
      footsteps: [90, 120],
    };

    // background loop
    this.bg = new Audio(this.paths.swamp);
    this.bg.loop = true;
    this.bg.volume = 0.35; // ambience level

    // state
    this.enabled = false;
    this.timers = [];
  }

  // helper: random delay in ms
  rdelay([a, b]) { return (a + Math.random() * (b - a)) * 1000; }

  // play a one-shot (new element so overlaps are allowed)
  playOne(name, vol = 0.8) {
    const a = new Audio(this.paths[name]);
    a.volume = vol;
    // fire-and-forget
    a.play().catch(() => { /* ignore if user gesture missing */ });
  }

  // schedule a repeating timed sound
  schedule(name, vol = 0.8) {
    const scheduleNext = () => {
      if (!this.enabled) return;
      const t = setTimeout(() => {
        if (!this.enabled) return;
        this.playOne(name, vol);
        scheduleNext(); // re-arm
      }, this.rdelay(this.ranges[name]));
      this.timers.push(t);
    };
    scheduleNext();
  }

  start() {
    if (this.enabled) return;
    this.enabled = true;
    // Start background loop
    this.bg.currentTime = 0;
    this.bg.play().catch(() => { /* will succeed after user click */ });

    // Schedule layered one-shots
    this.schedule('owl',     0.85);
    this.schedule('raven',   0.75);
    this.schedule('monster', 0.85);
  }

  stop() {
    this.enabled = false;
    // stop bg
    this.bg.pause();
    this.bg.currentTime = 0;
    // clear timers
    this.timers.forEach(t => clearTimeout(t));
    this.timers.length = 0;
  }

  toggle() { this.enabled ? this.stop() : this.start(); }
}

// Instantiate + wire the button
const sound = new SoundMgr();
const sndBtn = document.getElementById('soundToggle');
sndBtn.style.background = '#1a3';   // your original badge color
if (sndBtn) {
  sndBtn.addEventListener('click', () => {
    sound.toggle();
    // update badge look
    if (sound.enabled) {
      sndBtn.textContent = 'sound: on';
      sndBtn.style.background = '#1a3';   // green-ish
    } else {
      sndBtn.textContent = 'sound: off';
      sndBtn.style.background = '#1a3';   // your original badge color
    }
  });
}


class SpiderActor {
  constructor(runner){
    this.runner = runner;
    this.scale = rr(0.5, 0.8);            // size variation
    this.bobA = rr(2, 5);                 // tiny lateral bob
    this.bobF = rr(2, 3.5);
    this.respawn();
  }

  // spawn just off one edge so it crosses the whole screen
  respawn(){
    const W = canvas.width / dpr, H = canvas.height / dpr;
    const M = 120;                         // offscreen margin
    this.angle = Math.random() * Math.PI * 2;
    const vx = Math.cos(this.angle), vy = Math.sin(this.angle);

    if (Math.abs(vx) >= Math.abs(vy)) {
      // mostly horizontal travel
      this.x = (vx > 0) ? -M : W + M;
      this.y = rr(0.15*H, 0.95*H);
    } else {
      // mostly vertical travel
      this.x = rr(0.05*W, 0.95*W);
      this.y = (vy > 0) ? -M : H + M;
    }

    const speed = rr(40, 85);              // px/s
    this.vx = 1.8 * this.scale * speed * vx;
    this.vy = 1.8 * this.scale * speed * vy;
    this.t0 = now();
  }

  update(dt){
    this.runner.step(dt);
    // forward motion
    this.x += this.vx * dt;
    this.y += this.vy * dt;

    // subtle bob perpendicular to travel (looks more alive)
    const t = now() - this.t0;
    const px = -Math.sin(this.angle), py = Math.cos(this.angle); // perp
    const bob = Math.sin(t * this.bobF) * this.bobA * dt;
    this.x += px * bob;
    this.y += py * bob;

    // recycle when fully offscreen
    const W = canvas.width / dpr, H = canvas.height / dpr, M = 160;
    if (this.x < -M || this.x > W + M || this.y < -M || this.y > H + M) {
      this.respawn();
    }
  }

  draw(ctx){
    this.runner.draw(ctx, this.x, this.y, this.scale, this.angle, true);
  }
}



  // =============================================================
  // Canvas & assets
  // =============================================================
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
  const camStatus = document.getElementById('camStatus');
  const bg = new Image();
  const fg = new Image();
  let bgReady=false, fgReady=false;

  function setCanvasSize(w,h){
    canvas.width = Math.round(w * dpr);
    canvas.height = Math.round(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  if (CONFIG.bgUrl){ bg.onload = ()=>{ bgReady=true; setCanvasSize(bg.naturalWidth, bg.naturalHeight); }; bg.src = CONFIG.bgUrl; }
  else setCanvasSize(CONFIG.width, CONFIG.height);
  if (CONFIG.fgUrl){ fg.onload = ()=> fgReady=true; fg.src = CONFIG.fgUrl; }

  // =============================================================
  // Eye class
  // =============================================================
  class Eye {
    constructor({x,y,r}, i){
      this.x=x; this.y=y; this.r=r; this.i=i;
      this.gx=x; this.gy=y; // global gaze mapped for this eye
      this.pcX=x; this.pcY=y; // pupil center (smoothed)

      // Pupil dynamics (absolute pixels)
      this.pupil = 0.10 * r;
      this.pupilTarget = this.pupil;
      this.pupilLag = CONFIG.luminance.targetLag * rr(0.8, 1.3);
      this.pupilGain = rr(0.9, 1.1);

      // Blink
      this.nextBlinkAt = now() + rr(CONFIG.blinkMinDelay, CONFIG.blinkMaxDelay);
      this.blinkPhase = 0; // 0 open, 1 closed (with transitions)
      this.blinkT = 0;

      // Micro‑saccade scheduling
      this.nextSaccadeAt = now() + rr(CONFIG.micro.saccadeEveryMin, CONFIG.micro.saccadeEveryMax);
      this.sdx=0; this.sdy=0; this.sEnd=0;

      // Tremor phases
      this.ph1 = Math.random()*Math.PI*2;
      this.ph2 = Math.random()*Math.PI*2;
    }

    setGlobalGaze(x,y){ this.gx = x; this.gy = y; }

    update(dt, t, globalBrightness){
      // Blink FSM
      if (t >= this.nextBlinkAt && this.blinkPhase === 0){ this.blinkPhase = 0.0001; this.blinkT = 0; }
      if (this.blinkPhase > 0){
        this.blinkT += dt;
        if (this.blinkPhase < 1){ if (this.blinkT >= CONFIG.blinkDur){ this.blinkPhase = 1; this.blinkT = 0; } }
        else if (this.blinkPhase < 2){ if (this.blinkT >= CONFIG.blinkDur){ this.blinkPhase = 0; this.blinkT = 0; this.nextBlinkAt = t + rr(CONFIG.blinkMinDelay, CONFIG.blinkMaxDelay); } }
      }

      // Micro‑saccade
      if (t >= this.nextSaccadeAt && t > this.sEnd){
        const amp = rr(CONFIG.micro.saccadeAmpMin, CONFIG.micro.saccadeAmpMax) * this.r;
        const ang = Math.random()*Math.PI*2;
        this.sdx = Math.cos(ang)*amp; this.sdy = Math.sin(ang)*amp;
        const dur = rr(CONFIG.micro.saccadeDurMin, CONFIG.micro.saccadeDurMax);
        this.sEnd = t + dur;
        this.nextSaccadeAt = t + rr(CONFIG.micro.saccadeEveryMin, CONFIG.micro.saccadeEveryMax);
      }
      if (t >= this.sEnd){ this.sdx *= 0.85; this.sdy *= 0.85; }

      // Tremor
      const tremA = CONFIG.micro.tremorAmp * this.r;
      const tremX = Math.sin(t*CONFIG.micro.tremorHz1*2*Math.PI + this.ph1) * tremA * 0.5
                  + Math.sin(t*CONFIG.micro.tremorHz2*2*Math.PI + this.ph2) * tremA * 0.5;
      const tremY = Math.cos(t*CONFIG.micro.tremorHz1*2*Math.PI + this.ph1) * tremA * 0.5
                  + Math.cos(t*CONFIG.micro.tremorHz2*2*Math.PI + this.ph2) * tremA * 0.5;

      // Combine gaze + micro offsets, constrain to range
      const dx = (this.gx + this.sdx + tremX) - this.x;
      const dy = (this.gy + this.sdy + tremY) - this.y;
      const maxOff = this.r * CONFIG.gaze.range;
      const dist = Math.hypot(dx,dy) + 1e-6;
      const scl = Math.min(1, maxOff / dist);
      const tx = this.x + dx*scl;
      const ty = this.y + dy*scl;

      // Smooth pursuit
      this.pcX = lerp(this.pcX, tx, CONFIG.gaze.smooth);
      this.pcY = lerp(this.pcY, ty, CONFIG.gaze.smooth);

      // Pupil size from luminance (global -> per-eye)
      const L = Math.pow(clamp(globalBrightness,0,1), CONFIG.luminance.gamma);
      const base = lerp(CONFIG.pupilMax, CONFIG.pupilMin, L); // bright -> smaller
      const jitter = (Math.random()*2-1) * CONFIG.luminance.jitter * (CONFIG.pupilMax - CONFIG.pupilMin);
      const frac = clamp(base + jitter, CONFIG.pupilMin, CONFIG.pupilMax);
      const targetPx = frac * this.r * this.pupilGain;
      const alpha = clamp(dt / (this.pupilLag + 1e-6), 0, 1);
      this.pupil = lerp(this.pupil, targetPx, alpha);
    }

    draw(ctx){
      const r = this.r;
      const scleraR = r * CONFIG.scleraR;
      const irisR   = r * CONFIG.irisR;
      const limbalW = Math.max(1, r * CONFIG.limbalW);
      const pupilR  = clamp(this.pupil, r*CONFIG.pupilMin, r*CONFIG.pupilMax);

      // Blink amount 0..1
      let blinkAmt = 0;
      if (this.blinkPhase > 0 && this.blinkPhase < 1) blinkAmt = clamp(this.blinkT/CONFIG.blinkDur, 0, 1);
      else if (this.blinkPhase === 1) blinkAmt = 1;
      else if (this.blinkPhase > 1) blinkAmt = clamp(1 - this.blinkT/CONFIG.blinkDur, 0, 1);

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.scale(1.12, 0.96);

      // Clip to eye oval
      ctx.beginPath(); ctx.arc(0,0, scleraR, 0, Math.PI*2); ctx.clip();

      // // Sclera
      // const gradS = ctx.createRadialGradient(-scleraR*0.2, -scleraR*0.2, scleraR*0.2, 0, 0, scleraR);
      // gradS.addColorStop(0, '#f9fbff'); gradS.addColorStop(1, '#cfd7e6');
      // ctx.fillStyle = gradS; ctx.fillRect(-scleraR, -scleraR, scleraR*2, scleraR*2);

      // Sclera (spooky red tint + darker edges)
      const gradS = ctx.createRadialGradient(-scleraR * 0.2, -scleraR * 0.2, scleraR * 0.2, 0, 0, scleraR);

      // Soft off-white center with pinkish edges
      gradS.addColorStop(0, '#fff5f5'); // pale with slight red
      gradS.addColorStop(0.7, '#e6b3b3'); // pink tint
      gradS.addColorStop(1, '#4d0000'); // deep red/black edge

      ctx.fillStyle = gradS;
      ctx.fillRect(-scleraR, -scleraR, scleraR * 2, scleraR * 2);

      // Optional blood vessels
      ctx.strokeStyle = 'rgba(200,0,0,0.3)';
      ctx.lineWidth = 1;
      for (let i = 0; i < 5; i++) { // tweak count
        ctx.beginPath();
        let startX = (Math.random() - 0.5) * scleraR * 1.5;
        let startY = (Math.random() - 0.5) * scleraR * 1.5;
        ctx.moveTo(startX, startY);
        for (let j = 0; j < 3; j++) { // squiggle
          startX += (Math.random() - 0.5) * 10;
          startY += (Math.random() - 0.5) * 10;
          ctx.lineTo(startX, startY);
        }
        ctx.stroke();
      }

      // // Iris (blue theme)
      // const ix = (this.pcX - this.x) / 1.12;
      // const iy = (this.pcY - this.y) / 0.96;
      // const gradI = ctx.createRadialGradient(ix, iy, irisR*0.15, ix, iy, irisR);
      // gradI.addColorStop(0, '#a9cfe9');
      // gradI.addColorStop(0.55, '#1b5d7e');
      // gradI.addColorStop(1, '#0b2432');
      // ctx.beginPath(); ctx.arc(ix, iy, irisR, 0, Math.PI*2); ctx.fillStyle = gradI; ctx.fill();

      // Iris (red theme)
      const ix = (this.pcX - this.x) / 1.12;
      const iy = (this.pcY - this.y) / 0.96;
      const gradI = ctx.createRadialGradient(ix, iy, irisR * 0.15, ix, iy, irisR);

      // Replace blues with reds
      gradI.addColorStop(0, '#ffcccc');  // pale red/pink highlight
      gradI.addColorStop(0.55, '#b30000'); // deep red
      gradI.addColorStop(1, '#330000');   // near black/dark maroon

      ctx.beginPath();
      ctx.arc(ix, iy, irisR, 0, Math.PI * 2);
      ctx.fillStyle = gradI;
      ctx.fill();

      // Limbal ring
      ctx.lineWidth = limbalW; ctx.strokeStyle = 'rgba(10,20,30,0.9)';
      ctx.beginPath(); ctx.arc(ix, iy, irisR, 0, Math.PI*2); ctx.stroke();

      // Pupil + highlight
      ctx.beginPath(); ctx.arc(ix, iy, pupilR, 0, Math.PI*2); ctx.fillStyle = '#000'; ctx.fill();
      ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(ix - pupilR*0.5, iy - pupilR*0.6, pupilR*0.35, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill(); ctx.globalAlpha = 1;

      // Eyelids
      if (blinkAmt > 0){ const h = scleraR * blinkAmt; ctx.fillStyle = '#794618'; ctx.fillRect(-scleraR-2, -scleraR-2, scleraR*2+4, h+2); ctx.fillRect(-scleraR-2, scleraR-h-0, scleraR*2+4, h+2); }
      ctx.restore();

      // Outer shadow
      ctx.save(); ctx.shadowColor = 'rgba(0,0,0,0.55)'; ctx.shadowBlur = r*0.2; ctx.shadowOffsetY = r*0.07; ctx.beginPath(); ctx.arc(this.x, this.y, scleraR*1.02, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,0,0,0.001)'; ctx.stroke(); ctx.restore();
    }
  }

  // Create eyes
  const eyes = CONFIG.eyes.map((def,i)=> new Eye(def,i));

  // Create spiders
  const spiderRunner = new SpriteRunner(
    spiderSheet, SPRITE.cols, SPRITE.rows, SPRITE.total, SPRITE.fps
  );
  const spiders = Array.from({length: SPRITE.count}, () => new SpiderActor(spiderRunner));

  // =============================================================
  // Camera + MediaPipe Face Landmarker
  // =============================================================
  const video = document.getElementById('camera');
  let faceLandmarker = null; let lastVideoTime = -1;

  // Luminance sampling
  const lumSize = CONFIG.luminance.sampleSize;
  const lumCanvas = document.createElement('canvas');
  lumCanvas.width = lumSize; lumCanvas.height = lumSize;
  const lumCtx = lumCanvas.getContext('2d', { willReadFrequently: true });
  let brightness = 0.2; // EMA 0..1

  async function initCameraAndTracker(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width:{ideal: 640}, height:{ideal: 480} }, audio:false });
      video.srcObject = stream; await video.play();
      const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0');
      const filesetResolver = await vision.FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm');
      faceLandmarker = await vision.FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task' },
        runningMode: 'VIDEO', numFaces: 1
      });
      camStatus.textContent = 'camera: on'; camStatus.style.background = '#1a3';
    }catch(e){ camStatus.textContent = 'camera: blocked'; camStatus.style.background = '#631'; console.warn(e); }
  }

  function extractNormalizedGaze(result){
    if (!result || !result.faceLandmarks || result.faceLandmarks.length===0) return null;
    const lm = result.faceLandmarks[0];
    const RIGHT_IRIS = [468, 469, 470, 471, 472];
    const LEFT_IRIS  = [473, 474, 475, 476, 477];
    function avgXY(indices){ let sx=0, sy=0, n=0; for (const i of indices){ const p=lm[i]; if (!p) continue; sx+=p.x; sy+=p.y; n++; } return n? {x:sx/n,y:sy/n}:null; }
    let rI=avgXY(RIGHT_IRIS), lI=avgXY(LEFT_IRIS);
    if (!rI || !lI){ const R_EYE=[33,133], L_EYE=[362,263]; rI=avgXY(R_EYE); lI=avgXY(L_EYE); }
    if (!rI || !lI) return null;
    let nx = (rI.x + lI.x) * 0.5; let ny = (rI.y + lI.y) * 0.5;
    if (CONFIG.gaze.mirrorCamera) nx = 1 - nx;
    // Direction vector relative to center (parallel gaze model)
    let dirX = (nx - 0.5) * 2; let dirY = (ny - 0.5) * 2;
    const len = Math.hypot(dirX, dirY);
    let dirMag = Math.min(1, len);
    if (len > 1e-6){ dirX /= Math.max(1, len); dirY /= Math.max(1, len); }
    return { nx, ny, dirX, dirY, dirMag };
  }

  function updateBrightness(){
    try{
      const w = video.videoWidth, h = video.videoHeight; if (!w || !h) return;
      const S = lumSize; lumCtx.drawImage(video, 0, 0, S, S);
      const data = lumCtx.getImageData(0,0,S,S).data;
      let sum = 0; for (let i=0; i<data.length; i+=4){ const r=data[i], g=data[i+1], b=data[i+2]; const Y=0.2126*r+0.7152*g+0.0722*b; sum += Y; }
      const avg = (sum / (S*S)) / 255; brightness = lerp(brightness, avg, CONFIG.luminance.smooth);
    }catch{ /* ignore */ }
  }

  function processVideo(){
    if (!faceLandmarker || video.readyState < 2){ requestAnimationFrame(processVideo); return; }
    const tMs = performance.now();
    if (lastVideoTime !== video.currentTime){
      const res = faceLandmarker.detectForVideo(video, tMs);
      const gz = extractNormalizedGaze(res);
      updateBrightness();
      if (gz){
        const canvasW = (canvas.width / dpr), canvasH = (canvas.height / dpr);
        // Convergent point (near)
        const pointX = gz.nx * canvasW, pointY = gz.ny * canvasH;
        // Parallel direction (far)
        const dirX = gz.dirX, dirY = gz.dirY, dirMag = gz.dirMag;
        for (const e of eyes){
          const maxOff = e.r * CONFIG.gaze.range;
          // Directional target: offset from eye center along shared direction
          const dirOffLen = maxOff * dirMag;
          const dirTx = e.x + dirX * dirOffLen;
          const dirTy = e.y + dirY * dirOffLen;
          // Point target: converge to same canvas point (clamped by range)
          const dx = pointX - e.x, dy = pointY - e.y;
          const scl = Math.min(1, maxOff / (Math.hypot(dx,dy) + 1e-6));
          const ptTx = e.x + dx * scl, ptTy = e.y + dy * scl;
          // Blend by vergence
          const v = clamp(CONFIG.gaze.vergence, 0, 1);
          const gx = lerp(ptTx, dirTx, 1 - v);
          const gy = lerp(ptTy, dirTy, 1 - v);
          e.setGlobalGaze(gx, gy);
        }
      }
      lastVideoTime = video.currentTime;
    }
    requestAnimationFrame(processVideo);
  }

  // =============================================================
  // Main render loop
  // =============================================================
  let lastT = now();
  function frame(){
    const t = now(); const dt = Math.min(0.05, t - lastT); lastT = t;

    // BACKGROUND
    if (bgReady) ctx.drawImage(bg, 0, 0);
    else { ctx.fillStyle = '#05080a'; ctx.fillRect(0,0,canvas.width/dpr, canvas.height/dpr); }

    // EYES
    for (const e of eyes){ e.update(dt, t, brightness); e.draw(ctx); }

    // FOREGROUND MASK
    if (fgReady) ctx.drawImage(fg, 0, 0);

    // LAYER A: spiders behind eyes (crawl “on the scene” but under the pumpkin overlay)
    if (spiderReady) { for (const s of spiders){ s.update(dt); s.draw(ctx); } }

    // LAYER B: spiders on top of everything (uncomment to crawl over pumpkins)
    // if (spiderReady) { for (const s of spiders){ s.draw(ctx); } }

    requestAnimationFrame(frame);
  }


  // Kickoff
  await initCameraAndTracker();
  requestAnimationFrame(processVideo);
  requestAnimationFrame(frame);

  // Responsive fit (logical size stays constant unless bg sets it)
  function fitToViewport(){ if (!CONFIG.bgUrl){ const vw=Math.min(window.innerWidth, CONFIG.width); const vh=Math.min(window.innerHeight, CONFIG.height); canvas.style.width=vw+'px'; canvas.style.height=vh+'px'; } }
  window.addEventListener('resize', fitToViewport); fitToViewport();
  </script>
</body>
</html>
